#!/usr/local/bin/env python3'''			This Python 3 version 3.5.2 program was created by:			Todd Hugie	November 2016 - March 2017, after running a number of programs to verify			the data in the London data file (modified_everything_6-23.txt).  There were many typing errors			and inconsistency of data which made this project challenging.  Especially challenging were the			"As and See" dates.  They were presented in many different formats. There wasn't a lot of			standarization of the data, but there was good documentation to the typists on how the data			should be entered.  Also, many typing errors which some caused issues parsing through the data.			This Python program will run 3 passes through the data.				The first pass takes in teh modified_evertyhing file and accomplishes many complicated				tasks.  These include seperating as many of the meaningful data elements into their own				field delimited by the pipe "|" character.  The first pass identifies the * code,				seperates the performance date in yyyymmdd format, identifies theatre, performance name, and				identifies elements in the other * records.  One of the largest tasks accomplished was				to identify the As and See dates and get them in a format that in future tasks can be				imported into a database and create linking for the ladder purposes.				The second pass reads the file created by the first pass and inserts html italisized				codes where the initial creators of this data intended words to be italisized.				The third pass reads the file created by the second pass and separates out				actresses and actors from their roles.			The modified_everything_6-23.txt was created by Derek Miller of Harvard.			Here are the steps to create the modified_everything_6-23.txt data.			1.  Derek then manipulated that file and created			a number of London NPK and LSP files.  The process Derek used to do			this wasn't documented. Derek's program helped to format the data and to			uncompress the compressed dates. More specifically, Derek's program cleaned up the London			data and broke the data apart into lines that began with the *codes.			Also, the hex date that appears in positions 3-4 in			the NPK and LSP files was interpeted and Derek placed the translated dates			in the positions after the *code.  For example, *pYYYY space MM space DD.			2.  Mattie Burkert, an English professor at Utah State Univestiy took and			concatenated all the London NPK and LSP files into a file called			CONCATENATED.txt and the modified_everything_6-23.txt.			3.  The modified_everything_6-23.txt file was created to clean up the London			data and to break the data apart into lines that began with the *codes.			Also, the hex date that appears in positions 3-4 in			the NPK and LSP files was interpeted and Derek placed the translated dates			in the positions after the *code.  For example, *pYYYY space MM space DD.			This process made it much easier to then manipulate the data which is			accomplished with the following Python 3 program.			The *codes are as follows: (well as far as I (Todd Hugie) understands)				*p = Performance				*a= Afterpiece Title				*c = Comment extraneous comments				*d = Dance Untitled				*s = Song Untitled				*m = Music Untilted				*e = Entertainment Untitled				*i = Instrumental Title    (There was only one *i record in the original file)				*b = Ballet Title				*t = Trick Title  (There were no *t records in the original file)				*u = Monoluge with parts Title				*o = Opera Title				NOTE: There were no *t records in the modified everything file.  There were over a 100 *u				      entries but non of them were records of themselves.  They were included in other				      * records.  For example, there were some in *d, *a, etc. records. Some of the *u				      records were very strange.  I'm not sure if they were errors of sometype.  I left				      them alone.  You will find them in the data as they were. NOTES:      	1.  I found a *P in the modified_everything_6-23.txt file without any information      	in the record.  There were no other records associated with it.  So I deleted that      	records using a text editor.  It was found right after the *p 1752      	8 11 Venice Preserved  records.      	2.  I noticed that the theatre abbreviation was in every record until you get to a certain point in      	the modified_everything file.  I found that there were 22 records after the record,      	"c1770 6 22 hay A comedy to them" the one, that without the immortality of,...".  The next record starts      	with *s1773 and the data for the next 22 records is messed up.  The next good record is *p1770 9 22 dl Cybeline.      	 Mattie verified this.  After this point the records are good but the Theatre code only appears in the      	 *p records.  The program will go an insert the theatre code in all * records after this point except the *p record which already contains the theatre code.      	 3. This record, *s1732 4 25 dl *imË˜dl      	     was messed up in the everything_6-23.txt file.  It had some garbage.  With a text editor I cleaned      	     it up. The *i appears in the middle of *s record and the data in the *i record is garbage.      	 4.  There was a typo in the *d record of 1703 12 30, the squire of Alsatia.  The *d record had the to start an As date.  Took it out.      	 5.  There was a typo in an As Date in 1764 *d record of King's Alessandro Nell' Indie.  It was listed as "A"As.  Took out the "A".      	 6.  In the *u record of 1772 11 12 Before: (By particular desire)..., There were typo errors.  Not date information.  I put the date information      	  			in that record.  To program around all the typo errors was an enourmous task so where I could correct huge mistakes I did.  This was one.      	  	 There was another *u just after this one I fixed.  It was similar.  Same date but a couple of dates down. This record started with Acg Before:      	  	 UPDATE:  See number 2 above.  I found after this data that all of the *u fields had no date.  I updated those with the *p date      	 7.  In the *d record of 1772 22 21 King's As 14 Nov., but A New Grand Ballet -_;... the record was missing the theatre code.  I inserted it in.      	 8.  At the end of this record, 1773 9 20 a duplicate set of 1772 records started.  These 1772 records appeared above the 1773 records.             The records start with *a 1772 9 19 and went until 1772 12 31 (I do believe) then the correct sequence started again with the 1773 records.             I checked the 1772 section records and all of these records appearing in the middle of 1773 were duplicated.  So I removed them and created a            new Modified_everything_1-26.txt file.  You can go look at the modified_everything_1-6.txt records and see the dups I mention.         9.  I found many records with spelling errors.  Errors that would crash this program.  If there were many of the same type of errors I programmed            around the errors and left the records as they were created.  If I found one or two spelling errors I fixed them instead of taking a lot of            time to program around one or two errors.  I've documented those I've changed above.        10.  To take less time programming around date issues, I took 6 records, 1703 11 23 d record, 1668 6 15 P record             1668 6 16 P record, 1668 6 17 P record, 1668 6 18 P and 1767 11 25 P record and changed the dates from              "dd and% dd month" to "dd mm and% dd mm".  This matched the way other records were coded.        11.  This record, *d1742 1 2 dl I: +The Drunken Peasant=, as 29 Oct. 1741; II: A +Dutch Dance=, as 14 Oct. 1741;. had only 14 at the end.  Added Oct 1741.        12.  This record, *d1768 6 1 cg II: +The Merry Sailors=, as 9Oct. 1767., had typing error.  Changed to 9 Oct.        NOTE:  13 - 21 below changed for consistency to match other records throughout the file. These were a slight different.        13.  This record, *d1800 6 17 End: +Le Mariage Mexicain=, as 25 Feb.; End 2nd piece: +Telemaque=- [see 19 and  21 June]. was changed to add see 19 June.        14.  This record, *b1793 6 11 End Opera: +Iphiginia in Aulide=.  [see 15, 18 June].,  changed to [see 15 June and 18 June]        15.  This record, *d1800 6 17 End: +Le Mariage Mexicain=, as 25 Feb.; ...  [see 19 and 21 June], changed to [see 19 June and 21 June].        16.  This record, *p1661 6 22 vere The Alchemist.  See 00 Dec. 1660 [and 14 June 1661%. Changes to [and See	    17.  *p1669 1 15 lif Macbeth.  See 21 Dec. 1668 [and 12 Aug. 1668%. Changed to [and See	    18.  *a1696 11 20 lif The Loves of Mars and Venus.  See 14 [and 19% Nov.  Changed to [and See	    19.  *p1729 2 24 lif The Beggar's Opera.  See 1 Jan. [and 18 Oct. 1728%,	Changed to [and See	    20.  *p1708 3 2 dl Love for Love.  See 1 March [and 7 Feb.%, but Ben-Dogget.  Changed to [and See	    21.  *a1743 3 19 cg Perseus and Andromeda.  As 26 Feb.[and 8 Jan.%,  Changed to [and See	    22.  *p1722 4 26 lif Injur'd Love.  As 18Dec. 1721, but Snuffle-Morgan; Charmilla-Mrs Parler.  Changed to 18 Dec. 1721, put in a space.	    23.  *p1757 9 14 hay An Impromptu Faragolio.  [A variety of entertainments as 2, 8, 12 Sept.;% Changed dates to 2 Sept. and 8 Sept. and 12 Sept.	    24.  *p1768 11 10 cg Macbeth.  As 17 OCt.,   Changed to Oct.	    25.  *p1781 6 5 hay The Separate Maintenance. (see 15,  22 June); Changed to (see 15 June and see 22 June)	    26.  *p1710 6 29 queen's The Chances.  As 13Feb.[, but see 16 May%.;  Changed this record to As 13 Feb. [but see 16 May%.	    27.  *p1661 6 22 vere The Alchemist.  See 00 Dec. 1660 [and See 14 June 1661%.;  Changed to and See, too out [        28.  *a1750 11 29 dl The Anatomist.  As [of% 11 Sept.;  Changed to As 11 Sept.,  This was only record with that type of date format	    29.  *p1663 4 12 if The Adventures of Five Hours.  See 8 Jan.;  Change theatre to lif	    30.  *p1763 5 5 dl King Lear.  See [12 May 1763 and% 19 Nov. 1762, but Lear=-$Garrick=., Most See records with [ are formated [See   So I changed this record.	    31.  *p1668 6 15 bridges An Evening's Love?.  See [12 June and% 13 June. and the next 3 records were changed like number 30 above.	    32.  *p1767 11 25 dl The Provoked Wife.  See [18 Nov and% 25 Sept.,  Changed like number 30 and 31 above.  So See changed from See [ to [See,  took out the and		33.  *p1702 12 31  lif The Heiress;    Changed and took out extra space just before the theatre code (lif)		34.  *p1713 5 21 dl The Humorous Lieutenant.  As 11 Oct. 16 1712, but Caelia-Mrs Porter.  Changed by taking out 16 after October.  The Correct day was 11		35.  *s1730 12 12 gf then the next record was *d1689 10 0   That is a bad record. Out of order. No data.  Deleted.		36.  *d1757 3 28 cg [AAs 3 Jan.% Granier, Miss Hilliard, Lucas.  Changed by changing AAs to As.		37.   1734 10 26 dl III: La Follette s<?est  record took out the <   I needed this character as a delimiter for database import.  There was only one entry, this one in all the file.		38.  There were two files that had ^ in them.  This was an error.  Changed to correct character because I needed to use the ^ character as a delimeter in the database.        39.  There were a few records like this, *p1777 3 22 24[-29% none +Holy Week=.  They were all problems.  Took thme out.  They are all listed below.				*p1778 4 11 13[-18% none +Holy Week=.				*p1780 3 18 20[-25% none +Holy Week=.				*p1781 4 7 9[-14% none +Holy Week=.				*p4 2[-7% none +Holy Week=.				*p1788 3 15 17[-22% none +Holy Week=.				*p1789 4 4 6[-11% none +Holy Week=.				*p1791 4 16 18[-23% none +Holy Week=.				*p1793 3 23 25[-30% none +Holy Week=.				*p1799 3 16 18[-23% none  +Holy Week=.		40.  There were many records, 100s of records that had duplicate starting letters in them.  These all occured		         right after the date and theatre code and they started with the [ left bracket character.  I didn't document		         all of them but you can see them in the original file.  Anytime there was the date, theatre and then		         a left bracket [ character there was a duplicate letter.		         Here is an example of one, *d1731 11 3 dl [AA new Dance call'd %+The Masques=-.   See the double [AA.		41. These records had an *p with no *c but the word Comment appeared at right after the date and theatre in the *p record.		    There were comments in the *p record after the word Comment.  When we looked them up there should be an *c record		    with the comments that appreared within the *p record.  So we broke them up to look like the other 600 something		    *p and *c records that followed this convention.		    Here is an example of what we did.		    *p1702 03 00 none Comment.  [$King William= died on Sunday 8, and the playhouses were forbidden to act until after the <i>Coronation</i>, 23 April.]		    This is broken into the following:		    *p1702 03 00 none Comment.		    *c1702 03 00 none [$King William= died on Sunday 8, and the playhouses were forbidden to act until after the <i>Coronation</i>, 23 April.]		    Here they are listed by date.		    *p1702 03 00 none Comment.		    *p1745 05 04 king's Comment.		    *p1746 01 06 king's Comment.		    *p1746 06 03 dl Comment.		    *p1747 02 05 dl Comment.		    *p1747 02 19 dl Comment.		    *p1747 10 30 king's Comment.		    *p1748 02 06 hay Comment.		    *p1757 12 29 cg Comment.		    *p1758 05 06 cg Comment.		    *p1760 08 25 king's Comment.		    *p1768 11 03 king's Comment.		    *p1774 08 19 hg Comment.		42.  We discovered that some of the cast lists had the characters =r- between the performer and part.  I took the =r out of those entries.  About 800		          of them.   Example:  Amintas=r-$William  becomes Amintas-$William		43.  In the original file there were many garbage records after record, *c1770 6 22 hay A Comedy  to them:  the one, that without the immortality of        These records started with *s1733 4 21 leather should no        There were around 22 garbage records that were deleted.        44. It was decided to remove entries from volume 1 that have *p headers but are part of the editorial apparatus of the reference books rather        than the performance calendar. We had originally hoped to leave those *p entries intact, but because several plays are often combined under a single header,        they are causing problems for the parser, as demonstrated by Lauren Liebe's December 2018 testing.  We created a folder called Aditional Data Cleaning MB.        The file called modified_everything_11-20-18_withHathiAddtions_CommentsCombined.txt includes the *p records that were used for editorial.  The        modified_everthing_XX-XX-XX-with_HathiAddtions_CommentsCombined_Cuts.txt is the file with those removed.  A file called deleted_entries_MB_1.31.19.txt show        the records we removed.        45.'''#def filter(oldfile, newfile):# Create a dictionary for month conversion which will used for the As and See statements in the data to convert to digitmonths = {}months['Jan'] = '01'months['Feb'] = '02'months['Mar'] = '03'months['Apr'] = '04'months['May'] = '05'months['Jun'] = '06'months['Jul'] = '07'months['Aug'] = '08'months['Sep'] = '09'months['Oct'] = '10'months['Nov'] = '11'months['Dec'] = '12'months['oct'] = '10'months['dec'] = '12'#create the various variables used in pass 1.record_number = 0;i = 0;reclength = 0;theatre = "";theatrecouter = 0;starthere = 0;textpointer = 0;performercounter = 0;textdata = "";ASpointer = "0";SEEpointer = "0";mm = "";dd = "";mainmm = 0;maindd = 0;mainyy = 0;asyy = 0;asmm = 0;asdd = 0;findmm = 0;seeasbracket = "0";#open the latest modified everything file. Initially the input file was The modified_everything_6-23.txt#but as I fixed a lot of errors described above I created a new modified_everything file.  The#input file shown below is the latest file with those fixed.  The Londonfile1.txt is the output file#which will be read by pass 2.with open("modified_everything_02-06-19_withOrigDataHathiFixed.txt", "r", encoding="ISO-8859-1") as infile, open("Londonfile1.txt", "a", encoding="ISO-8859-1") as outfile1:#read a line at a time and parse character by character     while True:         text = infile.readline()         if len(text) == 0:            break		 # This section parses *p records         if text[0] == "*" and text[1] == "p":            record_number = record_number + 1;   #         outfile1.write ("{0}{1}{2}{3}{4}{5}{6}\n".format("|", record_number, "|", text[1], "|", text[2:6], "|"))   #          the statement above is another way to output the data but I used the print command for ease of use.            print (text[0], text[1], text[2:6], " ", sep = "", end = "", file=outfile1)            mm = "";            dd = "";            mainmm = 0;            maindd = 0;            mainyy = 0;            theatre = "";            # Pipe and define dates as yyyy mm dd and in the while statements find theatre code            #The challenge here was taking single digit months and days and creating two digits for consistency.            if text[8] == " ":         	   print ("0", text[7], " ",sep = "", end = "", file=outfile1)         	   mm = "0" + text[7]            else:         	   print (text[7], text[8], " ",sep = "", end = "", file=outfile1)         	   mm = text[7] + text[8]            if text[9] != " " and text[10] == " ":         	   print ("0", text[9], " ", sep = "", end = "", file=outfile1)         	   dd = "0" + text [9]         	   i = 11         	   starthere = i         	   theatrecounter = 0         	   theatre = ""         	   while True:        	      i = i + 1        	      theatrecounter = theatrecounter + 1        	      if text[i] == " ":         	      	 break            elif text[9] != " " and text[10] != " ":               print (text[9], text[10], " ", sep = "", end="", file=outfile1)               dd = text [9] + text[10]               i = 12               starthere = i               theatrecounter = 0               theatre = ""               while True:         	      i = i + 1         	      theatrecounter = theatrecounter + 1         	      if text[i] == " ":         	      	 break            elif text[9] == " " and text[10] != " " and text[11] != " ":               print (text[10], text[11], " ", sep = "", end = "", file=outfile1)               dd = text[10] + text[11]               i = 13               starthere = i               theatrecounter = 0               theatre = ""               while True:         	      i = i + 1         	      theatrecounter = theatrecounter + 1         	      if text[i] == " ":         	      	 break            else:         	   print ("0", text[10], " ", sep = "", end = "", file=outfile1)         	   dd = "0" + text[10]         	   i = 12         	   starthere = i         	   theatrecounter = 0         	   while True:         	      i = i + 1         	      theatrecounter = theatrecounter + 1         	      if text[i] == " ":         	      	 break            mainmm = mm;            maindd = dd;            theatre = text[i - theatrecounter:i];            i = i + 1;            reclength = i;            print (theatre, " ", sep = "", end = "", file=outfile1)            doublespace = 0;      #double space will be used to help identify performance name.            doublespace = text.find("  ");  #for almost all records the doublespace is at the end of performance name.            STtext = "";            STpointer = 0;            STpointer = text.find("St.");    # List out performance name.  Double spaces appear after the performance name, unless at the end of the record.  So check EofR            while True:         	   if doublespace == -1 and text[i] != "." and STpointer == -1:         	      print (text[i], sep = "", end = "", file=outfile1)         	      i = i + 1;         	   elif i < doublespace and text[i] != "." and STpointer == -1:         	      print (text[i], sep = "", end = "", file=outfile1)         	      i = i + 1;         	   elif STpointer != -1 and i < doublespace - 1:         	      print (text[i], sep = "", end = "", file=outfile1)         	      i = i + 1;         	   else:         	      print (text[i], sep = "", end = "", file=outfile1)         	      break            print (" ", sep = "", end = "", file=outfile1)            reclength = i + 1;            textpointer = 0;            textpointer = text.find("Edition")         # This section parses all record types for the As and See dates         # The code from this line until about line 62 or where the *c record gets processed         # we work on all the possible AS and SEE variations.  This was a major challenge and undertaking.         # There were many different possible variations and quite a few typo errors.  At times it was difficult         # to pick out these dates from regular text and comments.  All * code record dates were converted         # into a format that we can then input into a database.  The only * record that didn't go through         # this process were the *c and *u records.  The documentation states the *c records are free formatted         # comments.  There was a lot of inconsistency in the way that data was input.  The main purpose         # of *c records is that they are comments.  I left those as they were typed. I didn't take the *u records         # through this process because they were erros throughout those records.         if (text[0] == "*" and text[1] == "d" or text[0] == "*" and text[1] == "s" or text[0] == "*" and text [1] == "m" or               text[0] == "*" and text[1] == "e" or text[0] == "*" and text[1] == "b" or text[0] == "*" and text[1] == "o" or               text[0] == "*" and text[1] == "i" or text[0] == "*" and text[1] == "a" or text[0] == "*" and text[1] == "p"):            if text[1] != "p":                print (text[0], text[1], text[2:6], " ", mainmm, " ", maindd, " ", sep = "", end = "", file=outfile1)                print (theatre, " ", sep = "", end = "", file=outfile1)            mainyy = text[2:6];            if record_number > 35464 and text[1] != "p":  #In the file records after record number 35710 were formatted different so we format them like the previous.                reclength = starthere;            elif text[1] != "p":                reclength = starthere + len(theatre) + 1                if reclength + 4 < len(text):         	       if (text[reclength] == "[" and text[reclength + 1] == "A" and text[reclength + 2] == "s"         	              and text[reclength + 4] >= "0" and text[reclength + 4] <= "9" and reclength + 4 < len(text)):         	          print(text[reclength], sep = "", end = "", file=outfile1)         	          reclength = reclength + 1;            else:      #          reclength = reclength + theatrecounter - 3;  #  Took this out because if theatre was larger than count of 3 things messed up with dates.                reclength = reclength + 1;            #Put this statement in instead of the one above.            while reclength + 1 < len(text):                if text[reclength -1] == "w" and text[reclength] == "a" and text[reclength + 1] == "s":                   print (text[reclength], text[reclength + 1], " ", sep = "", end = "", file=outfile1)                   reclength = reclength + 3;                if reclength + 7 < len(text) and text[reclength + 7] == "-":  #Looks like an As date but it is a date range                   print (text[reclength], text[reclength + 1], text[reclength + 2], sep = "", end = "", file=outfile1)   #Added text[reclength + 2] it gave Hornp ipe see 1800 09 16                   reclength = reclength + 3;                if (text[reclength - 6] == "e" and text[reclength - 5] == "a" and text[reclength - 4] == "r"  #Looks like an As date but only comments "early as xxxx".                   and text[reclength -3] == "l" and text[reclength - 2] == "y"):                   print (text[reclength], text[reclength + 1], " ", sep = "", end = "", file=outfile1)                   reclength = reclength + 3;      #The next if statements are checking the word as in a sentence and skips processing the word as like an as date      #These statements allow us to skip over text where the word as appears but isn't an AS date.  Exception is As [date         #       if text[reclength] == "a" and text[reclength + 1] == "s" or text[reclength] == "A" and text[reclength + 1] == "s":  Changed to the statment below to add Thomas., but still need as                if (text[reclength] == "a" and text[reclength + 1] == "s" and text[reclength - 1] != "m" and text[reclength - 2] != "o" or #for this to happen the last word is Thomas.                     text[reclength] == "A" and text[reclength + 1] == "s"):                   if text[reclength + 3] >= "0" and text[reclength + 3] <= "9":                      print ("", sep = "", end = "", file=outfile1)  #Doing nothing here                   elif text[reclength + 3] != "[":                      print (text[reclength] + text[reclength + 1] + text[reclength + 2], sep = "", end = "", file=outfile1)                      reclength = reclength + 3;                   elif text[reclength + 3] == "[" and text[reclength + 4] >= "0" and text[reclength + 4] <= "9":                      print ("", sep = "", end = "", file=outfile1)  #Do nothing  This case we have something like As [5 Nov.                   else:                      print (text[reclength] + text[reclength + 1] + text[reclength + 2] + text[reclength + 3], sep = "", end = "", file=outfile1)                      reclength = reclength + 4;      #The next if statements are checking the word see in a sentence and skips processing the word see like a see date       #These statements allow us to skip over text where the word see appears but isn't an SEE date.  Exception is See [date                if (text[reclength] == "s" and text[reclength + 1] == "e" and text[reclength + 2] == "e" or                    text[reclength] == "S" and text[reclength + 1] == "e" and text[reclength + 2] == "e"):                   if text[reclength + 4] >= "0" and text[reclength + 4] <= "9":                      print ("", sep = "", end = "", file=outfile1)  #Doing nothing here                   elif text[reclength + 4] != "[":                      print (text[reclength] + text[reclength + 1] + text[reclength + 2], text[reclength + 3], sep = "", end = "", file=outfile1)                      reclength = reclength + 4;                   elif text[reclength + 4] == "[" and text[reclength + 5] >= "0" and text[reclength + 5] <= "9":                      print ("", sep = "", end = "", file=outfile1)  #Do nothing  This case we have something like As [5 Nov.                   else:                      print (text[reclength] + text[reclength + 1] + text[reclength + 2] + text[reclength + 3] + text[reclength + 4], sep = "", end = "", file=outfile1)                      reclength = reclength + 5;                if (text[reclength] == "A" and text[reclength + 1] == "s" and text[reclength + 2] == " " and text[reclength - 1] != "A" or                          text[reclength] == "S" and text[reclength + 1] == "e" and text[reclength + 2] == "e" or                          text[reclength] == "s" and text[reclength + 1] == "e" and text[reclength + 2] == "e" or                          text[reclength] == "a" and text[reclength + 1] == "s" and text[reclength + 2] == " "):         	       if text[reclength] == "A" or text[reclength] == "a":                                                 #This is an As date.   AS and SEE dates are delimited by the carrot ^ symbol.         	          print ("^", text[reclength] + text[reclength + 1], sep = "", end = "", file=outfile1)         	          reclength = reclength + 3;         	          if text[reclength] == "[":  #There are a few records that include two AS dates.  They start with this character [         	              print ("[", sep = "", end = "", file=outfile1)         	              reclength = reclength + 1;         	       elif text[reclength + 4] == "+" and text[reclength + 5] == "d":               # This is a See date with +dl= before the date         	          print ("^", text[reclength] + text[reclength + 1], text[reclength + 2], text[reclength + 3], sep = "", end = "", file=outfile1)         	          if "The Positive Man" in text:         	              print ("2", text)         	          print (text[reclength + 4], text[reclength + 5], text[reclength + 6], text[reclength + 7], text [reclength + 8], sep = "", end = "", file=outfile1)         	          reclength = reclength + 9;         	       else:                                                                           # This is a See date without the +dl         	          print ("^", text[reclength] + text[reclength + 1], text[reclength + 2], sep = "", end = "", file=outfile1)         	          if  "The Positive Man" in text:         	              print ("3", text)         	          reclength = reclength + 4;         	          if text[reclength] == "[": #This has a see date but includes a character [ between the see and the date         	              print (text[reclength] + text[reclength + 1], text[reclength + 2], text[reclength + 3], sep = "", end = "", file=outfile1)         	              reclength = reclength + 4;         	       asmm = "0";         	       asdd = "0";         	       asyy = "0";         	       seeasbracket = "0";  #This variable is set if we find a see date with [and between two months         	       seeasdd = "0";         	       while True:         	          if reclength + 2 > len(text):         	              break;         	          if text[reclength] > "9" or text[reclength] < "0" or text[reclength] == " " or text[reclength + 1] == "s":         	              print ("^", sep = "", end = "", file=outfile1)         	              break;         	          if text[reclength + 1] != " " and asdd == "0" and reclength + 3 < len(text): # Check to see if day is one digit or two.  If one put 0 in front         	              dd = text[reclength] + text[reclength + 1];         	              asdd = dd;         	              reclength = reclength + 3;         	              if text[reclength] == " ":    #This is a small case where we have extra spaces in the date such as As 17  Oct.         	                 reclength = reclength + 1;         	                             #The if below catches some see dates in this format.  Ex: see 14 [and 19% Nov.  We have to look ahead         	                             #  in the record to figure out if this is a real date and to get the correct month.         	              if text[reclength] == "[" and text[reclength + 1] == "a" and text[reclength + 2] == "n":         	                 seeasbraket = text[reclength] + text[reclength + 1] + text[reclength + 2] + text[reclength + 3] + text[reclength + 4];         	                 reclength = reclength + 5;         	                 if text[reclength + 1] == " " or text[reclength + 1] == "%":         	                    seeasdd = "0" + text[reclength];         	                    reclength = reclength + 3;         	                 else:         	                    seeasdd = text[reclength] + text[reclength + 1];         	                    reclength = reclength + 4;         	              findmm = (months[text[reclength] + text[reclength + 1] + text[reclength + 2]]);         	              asmm = findmm;         	              if asmm == "06" or asmm == "07" or asmm == "09":         	                 reclength = reclength + 4;         	              elif asmm == "03" or asmm == "04" and text[reclength + 3] != ".":         	                 reclength = reclength + 5;         	              elif asmm == "05":         	                 reclength = reclength + 2;         	              else:         	                 reclength = reclength + 3;         	              if (reclength + 3 > len(text)):         	                 if int(asmm) > int(mainmm):         	                   print (int(mainyy) - 1, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                   break;         	                 else:         	                   print (mainyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                   break;         	              elif text[reclength + 1] == "1": #        	                 print (text[reclength +1], text[reclength + 2], " ", sep = "", end = "", file=outfile1)         	                 asyy = text[reclength + 1] + text[reclength + 2] + text[reclength + 3] + text[reclength + 4]         	                 reclength = reclength + 5         	                 print (asyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                 break;         	              elif text[reclength + 2] == "1": #        	                 print (text[reclength +2], text[reclength + 3], " ", sep = "", end = "", file=outfile1)         	                 asyy = text[reclength + 2] + text[reclength + 3] + text[reclength + 4] + text[reclength + 5]         	                 reclength = reclength + 6         	                 print (asyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                 break;         	              elif text[reclength + 1] == "a" and text [reclength + 2] == "n" and text[reclength + 3] == "d":         	                 if int(asmm) > int(mainmm):         	                   print (int(mainyy) - 1, asmm, asdd, sep = "", end = "", file=outfile1)         	                 else:         	                   print (mainyy, asmm, asdd, sep = "", end = "", file=outfile1)         	                 print (" ", text[reclength + 1], text[reclength + 2], text[reclength + 3], text[reclength + 4], " ", sep = "", end = "", file=outfile1)         	                 reclength = reclength + 5;         	                 asdd = "0";    #     	                 break;         	              else:         	                 print (mainyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                 reclength = reclength + 1;         	                 break;         	          elif text[reclength + 1] == " " and asdd == "0" and reclength + 2 < len(text):         	              dd = "0" + text[reclength];         	              asdd = dd;         	              reclength = reclength + 2;         	              findmm = (months[text[reclength] + text[reclength + 1] + text[reclength + 2]]);         	              asmm = findmm;         	              if asmm == "06" or asmm == "07" or asmm == "09":         	                 reclength = reclength + 4;         	              elif asmm == "03" or asmm == "04" and text[reclength + 3] != ".":         	                   reclength = reclength + 5;         	              elif asmm == "05":         	                 reclength = reclength + 2;         	              else:         	                   reclength = reclength + 3;         	              if (reclength + 3 > len(text)):         	                 if int(asmm) > int(mainmm):         	                   print (int(mainyy) - 1, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                   break;         	                 else:         	                   print (mainyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                   break;         	              elif text[reclength + 1] == "1":         	                 asyy = text[reclength + 1] + text[reclength + 2] + text[reclength + 3] + text[reclength + 4]         	                 reclength = reclength + 5;         	                 print (asyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                 break;         	              elif text[reclength + 2] == "1":         	                 asyy = text[reclength + 2] + text[reclength + 3] + text[reclength + 4] + text[reclength + 5]         	                 reclength = reclength + 6;         	                 print (asyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                 break;         	              else:         	                 print (mainyy, asmm, asdd, "^", sep = "", end = "", file=outfile1)         	                 reclength = reclength + 1;         	                 break;         	          else:         	              print (text[reclength], sep = "", end = "", file=outfile1)         	              reclength = reclength + 1;     #           else:     #    	       print (text[reclength], sep = "", end = "")     #    	       reclength = reclength + 1;                if reclength < len(text):         	       print(text[reclength], sep = "", end = "", file=outfile1)         	       reclength = reclength + 1;            if len(text) == reclength:          	   reclength = reclength - 1;            if len(text) >= reclength:        # On some records we want to print a new line, others we don't.  Depends on how counts line up.         	   print ("|", file=outfile1)  #       	   print ("", file=outfile1)         # This section parses *c records         elif text[0] == "*" and text[1] == "c":            print (text[0], text[1], text[2:6], " ", mainmm, " ", maindd, " ", sep = "", end = "", file=outfile1)            print (theatre, " ", sep = "", end = "", file=outfile1)            if record_number > 35464:    #This point in the file the theatre code only shows up on the *p so we have to compensate.                reclength = starthere    #If more records are added then change this number.  Craziness, but there is a method to the madness.            else:                reclength = starthere + len(theatre) + 1            while reclength <= len(text):                if reclength + 2 > len(text):    #When nearing the end of the line print a pipe at the end of the record         	       print ("|", sep = "", end = "", file=outfile1)         	       reclength = reclength + 1;         	       print ("", file=outfile1)                else:         	       print (text[reclength], sep = "", end = "", file=outfile1)                reclength = reclength + 1;            while reclength < len(text):                print (text[reclength], end = "", file=outfile1)                reclength = reclength + 1;         # This section parses *u records         elif text[0] == "*" and text[1] == "u":            print (text[0], text[1], mainyy, " ", mainmm, " ", maindd, " ", sep = "", end = "", file=outfile1)            print (theatre, " ", sep = "", end = "", file=outfile1)            reclength = 2;            while reclength <= len(text):                if reclength + 2 > len(text):    #When nearing the end of the line print a pipe at the end of the record         	       print ("|", sep = "", end = "", file=outfile1)         	       reclength = reclength + 1;         	       print ("", file=outfile1)                else:         	       print (text[reclength], sep = "", end = "", file=outfile1)                reclength = reclength + 1;            while reclength < len(text):                print (text[reclength], end = "", file=outfile1)                reclength = reclength + 1;         elif text[:2] == "*z":            print (text, end = "", file=outfile1)            reclength = len(text)     infile.close()  #Close the input file     outfile1.close()  #Close the output file'''#  THIS SECTION STARTS PASS 2.#    PASS 2 Does the following:#        1. Reads the Londonfile1.txt file and creates a new output file called Londonfile2.txt.##      	2. To italicize words we use html coding so these words will appear italicized on the web.  Example:  _This text is italic=  becomes <i>This text is italic</i>'''#define variablesi = 0;#Open the output file from pass 1 as the input file for this pass.  Create a new output file.with open("Londonfile1.txt", "r", encoding="ISO-8859-1") as infile1, open("Londonfile2.txt", "a", encoding="ISO-8859-1") as outfile2:#read a line at a time and parse character by character     while True:         i = 0;         text = infile1.readline()         if len(text) == 0:  #There was a case where we have a few blank records created by the first pass.  The record length is 1, so skip rec.            break;         if len(text) == 1 or len(text) == 2: #There was a case where we have a few blank records created by the first pass.  The record length is 1 or 2, so skip record and read in next record.            text = infile1.readline()         while i < len(text):            if text[i] == "+":         #If we find text between a + and an = then the text is to be italicized.  We do that with html codes, <i> and end with </i>         	   print ("<i>", sep = "", end = "", file=outfile2) #Start italicized text with html italicized code <i>         	   i = i + 1;         	   while True:         	      if i >= len(text):         	         break;         	      if text[i] == "=":         	         print ("</i>", sep = "", end = "", file=outfile2)  #We end the italicized text with </i>         	         i = i + 1;         	         break;         	      elif i > len(text):         	         break;         	      else:         	         if text[i] != "|":         	            print (text[i], sep = "", end = "", file=outfile2)         	         i = i + 1;            else:         	   if i+2 == len(text) and text[i] == "." and text[i+1] != "|":   #Put in this if statement because there were a few records not         	      print (text[i], sep = "", end = "", file=outfile2)       #properly putting in a new line break.  This fixes that issue.         	      i = i + 1;         	   if text[i] == "|" and text[i+1] == "." and text[i+2] == "|" and i+2 < len(text): #These next two if statements cleanup some pipe (|) delimiting problems from pass 1.         	      i = i + 1;         	   elif text[i] == "|" and text[i+1] == "|" and i+1 < len(text):         	      i = i + 1;         	   elif text[i] == "|" and text[i+1] == " " and text[i+2] == "|" and i+2 < len(text):         	      i = i + 2;         	   if text[i] != "|":         	      print (text[i], sep = "", end = "", file=outfile2)         	   i = i + 1;infile1.close()  #Close the input fileoutfile2.close() #Close the output file#Section 3   To follow proper structure, there has to be a period at the end of the records, unless it's a hathi record.  For some reason a number of records don't end in period.  This fixes that problem.    #Open the output file from pass 1 as the input file for this pass.  Create a new output file.with open("Londonfile2.txt", "r", encoding="ISO-8859-1") as infile1, open("Londonfile3.txt", "a", encoding="ISO-8859-1") as outfile2:     hathi = False#read a line at a time and check for period and hathi.  Print out the record accordingly and fix any records that don't end in a period.     for text in infile1:         hathi = False         hathiperiod = False         if ".hathi" in text:            hathiperiod = True         elif "hathi" in text:         	hathi = True         if text[-1] != "." and text[-2] != "." and hathi == False and text[-3] != "." and text[-4] != "." and hathiperiod == False:            print(text[0:-1], ".", file=outfile2)         elif hathi == True and text[-8] != "." and text[-7] != ".":            print (text[0:-6],".", "hathi.", sep="", file=outfile2)         elif hathi == True:            print (text[0:-6],"hathi.", file=outfile2)         elif hathiperiod == True:            print (text[0:-7],".hathi.", file=outfile2)         else:            print (text, sep="", end="", file=outfile2)infile1.close()  #Close the input fileoutfile2.close() #Close the output file#Section 4   To create and *x record to be used in the database as phase 2 record.    #This shows The event records all in an *x with all the changes this program does with the data. Used to compare against originalwith open("Londonfile3.txt", "r", encoding="ISO-8859-1") as infile1, open("LondonFinal.txt", "a", encoding="ISO-8859-1") as outfile2:     firstTime = True     xrec = ""     for text in infile1:#         print (text, sep="", end="", file=outfile2)         if text[:2] != "*z":            xrec = (xrec + text.rstrip())            print (text, sep="", end="", file=outfile2)         if text[:2] == "*z":            print ("*x", xrec, sep="", file=outfile2)            print (text, sep="", end="", file=outfile2)            xrec=""infile1.close()  #Close the input fileoutfile2.close() #Close the output file'''THIS SECTION STARTS PASS 3.      PASS 3 Does the following:            1. Reads the Londonfile2.txt file and creates a new output file called LondonFinalFile.txt.            2. Parses through the input file, Londonfile2.txt, and identifies actresses and actors and their roles.            3. Parses through the file identifying the edition dates.            4. Parses through the file looking for special characters that identify what is to be done with the text between those types of characters.  For example,               text appearing between _ and = is to be italicized, the - character separates roles from actresses and actors, the character CNL means cast not listed,               the characters [ and % shows that the text between those characters are remarks in casts lists, material other than performers, roles, or titles.               The LISB - Instructions.pdf file explains all of this.''''''#define variablesi = 0;reclength = 0;starthere = 0;textpointer = 0;textdata = "";ASpointer = "0";SEEpointer = "0";seeasbracket = "0";pipecounter = 0;with open("Londonfile2.txt", "r", encoding="ISO-8859-1") as infile2, open("LondonFinalFile.txt", "a") as outfile3:#with open("Londonfile2.txt", "r", encoding="ISO-8859-1") as infile2:#read a line at a time and parse character by character     while True:         i = 0;         pipecounter = 0;         text = infile2.readline()         if len(text) == 0:            break;         reclength = i + 1;         textpointer = 0;         textpointer = text.find("Edition");  #We use this to find Edition in the text and set it apart as its own field.   # Now start processing the * record after finding actors/actresses name.  Separate out fields, etc.         while reclength < len(text):            while True:         	   if i >= len(text):         	      break;         	   if text [i] == "|" and text[i+1] == " " and text [i+2] == "|" and i < len(text):   #This case rarely happens but there will be nothing between pipes so take it out.         	      i = i + 1;                         #Looking for Edition in the next if statement         	   if (text[i] == "[" and text[i+1] == "E" and text[i+2] == "d" and text[i+3] == "i" and text[i+4] == "t" and text[i+5] == "i" and text[i+6] == "o" and         	      text[i+7] == "n" and i < len(text)):         	      print (text[i], text[i+1], text[i+2], text[i+3], text[i+4], text[i+5], text[i+6], text[i+7], sep = "", end = "", file=outfile3)         	      i = i + 8;         	      while True:         	         print (text[i], sep = "", end = "", file=outfile3)         	         i = i + 1;         	         if text[i] == "%":#         	            print (text[i], "|", sep = "", end = "", file=outfile3)  Need to pipe edition at some point         	            print (text[i], sep = "", end = "", file=outfile3)         	            i = i + 1;         	            break;         	         else:         	            print (text[i], sep = "", end = "", file=outfile3)         	            i = i + 1;     #    	            break;         	         if i+1 >= len(text):         	            break;                           #; below is at the end of actor/actresses and roles unless in performance name then or, appears         	   elif i+4 < len(text) and text[i] == ";" and text[i+4] != ",": #Right bracket as the delimiter between two names with if no or, in the name.         	      if reclength < len(text):         	         print (text[i], "}", sep  = "", end = "", file=outfile3)         	         i = i + 1;         	         break;         	      i = i + 1;         	   else:         	      print (text[i], sep = "", end = "", file=outfile3)         	      i = i + 1;         	      break;            reclength = reclength + 1;         if i != reclength:    #We need to print a new line but only at the end of a line and when the counts of i and reclength don't equal each other.            print ("", file=outfile3)infile2.close()  #Close the input fileoutfile3.close() #Close the output file'''